'''
--------------------------------------------------------------------------------------
6.5 딕셔너리를 XML 로 바꾸기

문제 : 파이썬 딕셔너리 데이터를 받아서 XML 로 바꾸기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- xml.etree.ElementTree 라이브러리는 파싱에 일반적으로 사용하지만 XML 문서를 생성할 때 사용
--------------------------------------------------------------------------------------
'''

from xml.etree.ElementTree import Element
from xml.etree.ElementTree import tostring

def dict_to_xml(tag, d):
    '''
    간단한 dict를 xml 로 변환하기
    '''
    elem = Element(tag)
    for key, val in d.items():
        child = Element(key)
        child.text = str(val)
        elem.append(child)
    return elem

s = {'name' : 'GOOD', 'share' : 100, 'price' : 490.1}
e = dict_to_xml('stock', s)

# Element 인스턴스
print(e)

# 바이트 문자열
print(tostring(e))

# 요소에 속성 넣기
e.set('_id', '1234')
print(tostring(e))

'''
--------------------------------------------------------------------------------------
- XML을 생성할 때 단순히 문자열을 사용 
--------------------------------------------------------------------------------------
'''

from xml.sax.saxutils import escape, unescape

def dict_to_xml_str(tag, d):
    '''
    간단한 dict 를 xml로 변환하기
    '''
    parts = ['<{}>'.format(tag)]
    for key, val in d.items():
        parts.append('<{0}>{1}</{0}>'.format(key, val))
    parts.append('</{}>'.format(tag))
    return ''.join(parts)

d = {'name' : '<spam>'}

# 문자열 생성
dict_to_xml_str('item', d)

# 올바른 XML 생성
e = dict_to_xml_str('item', d)
print(tostring(e))

# 문자를 수동으로 이스케이핑하기
print(escape('<spam>'))

print(unescape())

'''
--------------------------------------------------------------------------------------
- 올바른 출력을 만드는 것 외에도 문자열 대신 Element 인스턴스를 만드는 것이 좋은 이유는
  이들을 더 쉽게 합쳐 큰 문서를 만들 수 있기 때문이다
  
- Element 인스턴스는 XML 파싱에 대한 염려 없이 여러 방법으로 처리할 수 있다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
6.6 XML 파싱, 수정, 저장

문제 : XML 문서를 읽고, 수정하고 수정 내용을 XML에 반영하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- xml.etree.ElementTree 모듈 사용(pred.xml)
--------------------------------------------------------------------------------------
'''

from xml.etree.ElementTree import parse, Element

doc = parse('pred.xml')
root = doc.getroot()

print(root)

# 요소 몇 개 제거하기
root.remove(root.find('sti'))
root.remove(root.find('cr'))

# <nm> ... </nm> 뒤에 요소 몇 개 삽입하기
root.getchildren().idex(root.find('nm'))
e = Element('spam')
e.text = 'This is a test'
root.insert(2, e)

# 파일에 쓰기
doc.write('newpred.xml', xml_declaration=True)

'''
--------------------------------------------------------------------------------------
- 어떤 요소를 제거하면 부모의 remove() 메소를 사용해 바로 위에 있는 부모로부터 제거된다

- 새로운 요소를 추가하면 부모에 대해서도 insert() 와 append() 메소드를 사용

- 모든 요소는 element[i] 또는 element[i:j] 와 같이 인덱스와 슬라이스 명령으로도 접근
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
6.7 네임스페이스로 XML 문서 파싱

문제 : XML 문서를 파싱할 때 XML 네임스페이스(namespace) 사용 
--------------------------------------------------------------------------------------
'''

# 동작하는 쿼리
doc.findall('author')
doc.find('content')

# 네임스페이스 관련 쿼리(동작하지 않음)
doc.find('content/html')

# 조건에 맞는 경우에만 동작
doc.find('content/{http://www.w3.org/1999/xhtml}html')

# 동작하지 않음
doc.findtext('content/{http://wwww.w3.org/1999/xhtml}html/head/title')

# 조건에 일치함
doc.findtext('content/{http://www.w3.org/1999/xhtml}html')

'''
--------------------------------------------------------------------------------------
- 유클리드 클래스로 네임스페이스 감싸기
--------------------------------------------------------------------------------------
'''

class XMLNamespaces:
    def __init__(self, **kwargs):
        self.namespaces = {}
        for name, uri in kwargs.items():
            self.register(name, uri)

    def register(self, name, uri):
        self.namespaces[name] = '{'+uri+'}'

    def __call__(self, path):
        return path.format_map(self.namespaces)

ns = XMLNamespaces(html='http://www.w3.org/1999/xhtml')

doc.find(ns('content/{html}html'))

'''
--------------------------------------------------------------------------------------
- iterparse() 함수를 사용한다면 네임스페이스 처리의 범위에 대해서 정보 얻기
--------------------------------------------------------------------------------------
'''

from xml.etree.ElementTree import iterparse

for evt, elem in iterparse('ns2.xml', ('end', 'start-ns', 'end-ns')):
    print(evt, elem)





'''
--------------------------------------------------------------------------------------
6.8 관계형 데이터베이스 작업

문제 : 관계형 데이터베이스에 선택, 삽입, 행 삭제(select, insert, delete row) 등의 작업 수행
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 파이썬에서 데이터 행을 나타내는 표준은 튜플 시퀀스
--------------------------------------------------------------------------------------
'''

stocks = [('GOOD', 100, 490.1), ('AAPL', 50, 545.75),
          ('FB', 150, 7.45), ('HPQ', 75, 33.2)]

'''
--------------------------------------------------------------------------------------
- 데이터베이스를 연결
  connect() 함수에 데이터베이스 이름, 호스트 이름, 사용자 이름, 암호 등 필요한 정보 넣기
--------------------------------------------------------------------------------------
'''

import sqlite3

stocks = [('GOOD', 100, 490.1), ('AAPL', 50, 545.75),
          ('FB', 150, 7.45), ('HPQ', 75, 33.2)]

db = sqlite3.connect('database.db')

# 커서를 만든 후에 SQL 쿼리를 실행할 수 있다
c = db.cursor()
c.execute('create table portfolio (symbol text, share integer, price real)')
db.commit()

# 데이터에 행의 시퀀스 삽입
c.executemany('insert into portfolio values (?,?,?)', stocks)
db.commit()

# 쿼리 수행
for row in db.execute('select * from portfolio'):
    print(row)

# 사용자가 입력한 파라미터를 받는 쿼리를 수행하려면 ?를 사용해 파라미터를 이스케이핑
min_price = 100

for row in db.execute('select * from portfolio where price >= ?', (min_price,)):
    print(row)





'''
--------------------------------------------------------------------------------------
6.9 16진수 인코딩, 디코딩

문제 : 문자열로 16진수를 바이트 문자열로 디코딩하거나 바이트 문자열을 16진법으로 인코딩 하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 문자열을 16진수로 인코딩하거나 디코딩하려면 binascii 모듈 사용
--------------------------------------------------------------------------------------
'''

# 최초 바이트 문자열
s = b'hello'

# 16진법으로 인코딩
import binascii

h = binascii.b2a_hex(s)

print(h)

# base64 모듈에도 유사한 기능
import base64

h = base64.b16encode(s)

print(h)
print(base64.b16decode(h))

# 유니코드 사용
h = base64.b16encode(s)
print(h.decode('ascii'))

'''
--------------------------------------------------------------------------------------
- base64.b16decode() 와 base64.b16encode() 함수는 대문자에만 동작

- binascii 는 대소문자를 가리지 않는다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
Chapter7 함수
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
7.1 매개변수 개수에 구애 받지 않는 함수 작성

문제 : 입력 매개변수 개수에 제한이 없는 함수 작성하기
--------------------------------------------------------------------------------------
'''



