'''
--------------------------------------------------------------------------------------
Chapter 5 파일과 입출력
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
5.1 텍스트 데이터 읽고 쓰기

문제 : 텍스트 데이터를 읽거나 써야 하는데 ASCII, UTF-8, UTF-16과 같이 서로 다른 인코딩 사용하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 텍스트 파일을 읽기 위해 open() 함수에 rt 모드 사용
--------------------------------------------------------------------------------------
'''

# 파일 전체를 하나의 문자열로 읽기
with open('e:\data\somefile.txt', 'rt') as f:
    data = f.read()
    print(data)

# 파일의 줄을 순환
with open('e:\data\somefile.txt', 'rt') as f:
    for line in f:
        print(line)

# 텍스트 데이터 쓰기
with open('e:\data\somefile.txt', 'wt') as f:
    f.write()
    f.write()

# 리다이렉트한 print 문
with open('e:\data\somefile.txt', 'wt') as f:
    print(line, file=f)
    print(line, file=f)

'''
--------------------------------------------------------------------------------------
- 파일의 끝에 내용을 추가하려면 at 모드로 open() 사용

- 기본적으로 파일을 읽고 쓸 때 sys.getdefaultencoding() 으로 확인할 수 있는 시스템 기본 인코딩 사용
  with open('d:\data\somefile.txt', 'rt', encoding='latin-1') as f:
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- with 문이 파일을 사용할 콘텍스트를 만든다. 컨트롤이 with 블록을 떠나면 파일이 자동으로 닫힌다
  with 문을 꼭 사용하지 않아도 되지만 그럴 때는 반드시 파일을 닫아야 한다
--------------------------------------------------------------------------------------
'''

f = open('e:\data\somefile.txt', 'rt')
data = f.read()
f.close()

'''
--------------------------------------------------------------------------------------
- 줄바꿈
--------------------------------------------------------------------------------------
'''

# 줄바꿈 변환 없이 읽기
with open('e:\data\somefile.txt', 'rt', newline='') as f:
    data = f.read()
    print(data)

# 줄바꿈 변환 사용(기본)
f = open('e:\data\somefile.txt', 'rt')

print(f.read())

# 줄바꿈 변환 미사용
g = open('e:\data\somefile.txt', 'rt', newline='')

print(g.read())

'''
--------------------------------------------------------------------------------------
- 인코딩 에러의 일반적인 에러 처리 방식
--------------------------------------------------------------------------------------
'''

# 알 수 없는 문자를 유니코드 U+fffd로 치환
f = open('e:\data\somefile.txt', 'rt', encoding='ascii', errors='replace')

print(f.read())

# 알 수 없는 문자를 무시
g = open('e:\data\somefile.txt', 'rt', encoding='ascii', errors='ignore')

print(f.read())





'''
--------------------------------------------------------------------------------------
5.2 파일에 출력

문제 : print() 함수의 결과를 파일에 출력하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- print()에 file 키워드 인자 사용
--------------------------------------------------------------------------------------
'''

with open('e:\data\somefile.txt', 'rt') as f:
    print('Hello World!', file=f)

'''
=> 파일을 텍스트 모드로 열었는지 꼭 확인해야 한다
   바이너리 모드로 파일을 열면 출력에 실패
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
5.3 구별자나 종단 부호 바꾸기

문제 : print()를 사용해 데이터를 출력할 때 구분자나 종단 부호(line ending) 바꾸기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- print() 에 sep 과 end 키워드 인자 사용
--------------------------------------------------------------------------------------
'''

print('ACME', 50, 91.5)

print('ACME', 50, 91.5, sep=',')

print('ACME', 50, 91.5, sep=',', end='!!\n')

'''
--------------------------------------------------------------------------------------
- 출력의 개행 문자(newline)를 바꿀 때도 end 인자 사용
--------------------------------------------------------------------------------------
'''

for i in range(5):
    print(i, end=' ')

'''
--------------------------------------------------------------------------------------
- str.join() 으로 아이템을 구분하는 문자를 스페이스 공백문 이외로 바꾸기
--------------------------------------------------------------------------------------
'''

a = ('ACME', '50', '91.5')

print(','.join(a))

print(','.join(str(x) for x in a))





'''
--------------------------------------------------------------------------------------
5.4 바이너리 데이터 읽고 쓰기

문제 : 이미지나 사운드 파일 등 바이너리 데이터를 읽고 쓰기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- open() 함수에 rb와 wb 모드를 사용해서 바이너리 데이터를 읽거나 쓰기
--------------------------------------------------------------------------------------
'''

# 파일 전체를 하나의 바이트 문자열로 읽기
with open('e:\data\somefile.txt', 'rb') as f:
    data = f.read()
    print(data)

# 바이너리 데이터 파일에 쓰기
with open('e:\data\somefile.txt', 'wb') as f:
    f.write(b'Hello World')

'''
--------------------------------------------------------------------------------------
- 데이터에 인덱스나 순환으로 반환된 값은 바이트 문자열이 아닌 정수 바이트 값이 된다
--------------------------------------------------------------------------------------
'''

# 텍스트 문자열
t = 'Hello World'

print(t[0])

for c in t:
    print(c)

# 바이트 문자열
b = b'Hello World'

print(b[0])

for c in b:
    print(c)

'''
--------------------------------------------------------------------------------------
- 바이너리 모드 파일로부터 텍스트를 읽거나 쓰려면 인코딩이나 디코딩 과정이 꼭 필요하다
--------------------------------------------------------------------------------------
'''

with open('e:\data\somefile.txt', 'rb') as f:
    data = f.read(16)
    text = data.decode('utf-8')

with open('e:\data\somefile.txt' 'wb') as f:
    text = 'Hello World'
    f.write(text.encode('uft-8'))

'''
--------------------------------------------------------------------------------------
- 바이너리 입출력 시 잘 알려지지 않은 기능으로 배열이나 C 구조체와 같은 객체를 bytes 객체로
  변환하지 않고 바로 쓸 수 있다
--------------------------------------------------------------------------------------
'''

import array

nums = array.array('i', [1, 2, 3, 4])

with open('e:\data\somefile.txt', 'wb') as f:
    f.write(nums)

'''
--------------------------------------------------------------------------------------
- readinto() 메소드를 사용하면 여러 객체의 바이너리 데이터를 직접 메모리에 읽어 들일 수 있다
--------------------------------------------------------------------------------------
'''

import array

a = array.array('i', [0,0,0,0,0,0,0,0])

with open('e:\data\somefile.txt', 'rb') as f:
    f.readinto(a)

print(a)





'''
--------------------------------------------------------------------------------------
5.5 존재하지 않은 파일에 쓰기

문제 : 파일이 파일 시스템에 존재하지 않을 때, 데이터를 파일에 쓰기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- open() 에 x모드를 사용해서 해결
--------------------------------------------------------------------------------------
'''

with open('d:\data\somefile.txt', 'wt') as f:
    f.write('Hello\n')

'''
=> 파일이 바이너리 모드이면 xt 대신 xb 사용!
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 파일을 쓸 때 발생할 수 있는 문제점(실수로 파일을 덮어쓰는 등)을 아주 우아하게 피해 가는 코드
  혹은 파일을 쓰기 전에 파일이 있는지 확인하는 방법
--------------------------------------------------------------------------------------
'''

import os
if not os.path.exists('d:\data\somefile.txt'):
    with open('d:\data\somefile.txt', 'wt') as f:
        f.write('Hello\n')
else:
    print('File already exists!')

'''
=> 확실히 x 모드를 사용하는 것이 훨씬 깔끔 
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
5.6 문자열에 입출력 작업하기

문제 : 파일 같은 객체에 동작하도록 작성한 코드에 텍스트나 바이너리 문자열을 제공
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- io.StringIO()와 io.BytesIO() 클래스로 문자열 데이터에 동작하는 파일 같은 객체 생성
--------------------------------------------------------------------------------------
'''

import io

s = io.StringIO()

s.write('Hello World\n')
print('This is a test', file=s)


# 기록한 모든 데이터 얻기
print(s.getvalue())

# 기존 문자열을 파일 인터페이스로 감싸기
s = io.StringIO('Hello\nWorld\n')

print(s.read(4))
print(s.read())

'''
--------------------------------------------------------------------------------------
- io.StringIO() 클래스는 텍스트에서만 사용
  바이너리 데이터를 다룰 때는 io.BytesIO 클래스 사용
--------------------------------------------------------------------------------------
'''

import io

s = io.BytesIO()
s.write(b'binary data')

print(s.getvalue())

'''
--------------------------------------------------------------------------------------
- 유닛 테스트를 할 때, StringIO로 테스트 데이터를 담고 있는 객체를 만들어 일반 파일에 동작하는 함수 사용
  
- StringIO 와 BytesIO 인스턴스가 올바른 정수 파일 디스크립터를 가지고 있지 않다!
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
5.7 압축된 데이터 파일 읽고 쓰기

문제 : gzip 이나 bz2 로 압축한 파일을 읽거나 쓰기 
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- gzip 과 bz2 모듈 사용(open() 을 사용하는 구현법의 대안)
--------------------------------------------------------------------------------------
'''

# gzip 압축
import gzip
with gzip.open('d:\data\somefile.gz', 'rt') as f:
    text = f.read()

# bz2 압축
import bz2
with bz2.open('d:\data\somefile.bz2', 'rt') as f:
    text = f.read()


# 압축한 데이터 사용방법
# gzip 압축
import gzip
with gzip.open('d:\data\somefile.gz', 'wt') as f:
    f.write(text)

# bz2 압축
import bz2
with bz2.open('d:\data\somefile.bz2', 'wt') as f:
    f.write(text)

'''
=> 모든 입출력은 텍스트를 사용하고 유니코드 인코딩/디코딩 수행
   바이너리 데이터를 사용하고 싶다면 rb 또는 wb 모드 사용!
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 압축한 데이터를 쓸 때는 compresslevel 인자로 압축 정도를 지정
--------------------------------------------------------------------------------------
'''

with gzip.open('d:\data\somefile.gz', 'wt', compresslevel=5) as f:
    f.write(text)

'''
--------------------------------------------------------------------------------------        
- gzip.open() 과 bz2.open() 을 기존에 열려 있는 바이너리 파일의 상위에 위치시키기
--------------------------------------------------------------------------------------
'''

import gzip

f = open('d:\data\somefile.gz', 'rb')
with gzip.open(f, 'rt') as g:
    text = g.read()





'''
--------------------------------------------------------------------------------------        
5.8 고정 크기 레코드 순환

문제 : 파일을 줄 단위로 순환하지 않고, 크기를 지정해서 그 단위별 순환하고 싶다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------        
- iter() 함수와 functools.partial() 을 사용
--------------------------------------------------------------------------------------
'''

from functools import partial

RECORD_SIZE = 32

with open('d:\data\somefile.txt', 'rb') as f:
    records = iter(partial(f.read, RECORD_SIZE), b'')
    for i in records:
        pass

'''
=> 위 예제는 records 객체는 파일의 마지막에 도달할 때까지 고정 크기 데이터를 생산하는 순환 객체이다
   하지만 파일의 크기가 지정한 크기의 정확한 배수가 아닌 경우 마지막 아이템의 크기가 예상보다 작을 수도 있다
--------------------------------------------------------------------------------------
'''




















































