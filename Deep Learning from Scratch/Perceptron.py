'''
--------------------------------------------------------------------------------------
- AND 게이트 함수
--------------------------------------------------------------------------------------
'''

def AND(x1, x2):
    w1, w2, theta = 0.5, 0.5, 0.7
    tmp = x1 * w1 + x2 * w2
    if tmp <= theta:
        return 0
    elif tmp > theta:
        return 1

print(AND(0, 0))
print(AND(1, 0))
print(AND(0, 1))
print(AND(1, 1))



'''
--------------------------------------------------------------------------------------
- 가중치와 편향 도입

    0 (b + w1*x1 + w2*x2 <= 0)
y = 
    1 (b + w1*x1 + w2*x2 > 0)
--------------------------------------------------------------------------------------
'''

import numpy as np

x = np.array([0, 1])
w = np.array([0.5, 0.5])
b = -0.7

print(w * x)                # 입력
print(np.sum(w * x))        # 가중치
print(np.sum(w * x) + b)    # 편향

'''
=> np.sum() 메소드는 입력한 배열에 담긴 모든 원소의 총합
--------------------------------------------------------------------------------------
'''



'''
--------------------------------------------------------------------------------------
- 가중치와 편향을 도입한 AND 게이트
--------------------------------------------------------------------------------------
'''

import numpy as np

def AND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    tmp = np.sum(w * x) + b
    if tmp <= 0:
        return 0
    elif tmp > 0:
        return 1

'''
=> w1 과 w2 는 각 입력 신호가 결과에 주는 영향력(중요도)을 조절하는 매개변수고,
   편향은 뉴런이 얼마나 쉽게 활성화(결과로 1을 출력) 하느냐를 조정하는 매개변수
--------------------------------------------------------------------------------------
'''



'''
--------------------------------------------------------------------------------------
- NAND 게이트 함수
  OR 게이트 함수
--------------------------------------------------------------------------------------
'''

import numpy as np

def NAND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5])   # AND와는 가중치(w와 b)만 다르다
    b = 0.7
    tmp = np.sum(w * x) + b
    if tmp <= 0:
        return 0
    elif tmp > 0:
        return 1

def OR(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])    # AND와는 가중치(w와 b)만 다르다
    b = -0.2
    tmp = np.sum(w * x) + b
    if tmp <= 0:
        return 0
    elif tmp > 0:
        return 1


'''
- XOR 게이트

  (b, w1, w2) = (-0.5, 1.0, 1.0) 일때
  
        0 (-0.5 + x1 + x2 <= 0)
  y = 
        1 (-0.5 + x1 + x2 > 0)

=> XOR 게이트의 경우 직선하나로 0, 1 을 나누기란 불가능!!

=> 퍼셉트론은 직선하나로 나눈 영역만 표현할 수 있다는 한계!

=> 곡선의 영역을 비선형 영역, 직선의 영역을 선형 영역
'''



'''
--------------------------------------------------------------------------------------
- XOR 게이트 함수
--------------------------------------------------------------------------------------
'''

import numpy as np

def NAND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5])  # AND와는 가중치(w와 b)만 다르다
    b = 0.7
    tmp = np.sum(w * x) + b
    if tmp <= 0:
        return 0
    elif tmp > 0:
        return 1

def OR(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])  # AND와는 가중치(w와 b)만 다르다
    b = -0.2
    tmp = np.sum(w * x) + b
    if tmp <= 0:
        return 0
    elif tmp > 0:
        return 1

def AND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    tmp = np.sum(w * x) + b
    if tmp <= 0:
        return 0
    elif tmp > 0:
        return 1

# =====================================================================================

def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    y = AND(s1, s2)
    return y

print(XOR(0, 0))
print(XOR(1, 0))
print(XOR(0, 1))
print(XOR(1, 1))